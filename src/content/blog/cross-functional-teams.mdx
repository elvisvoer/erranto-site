---
title: "On cross-functional teams"
slug: "cross-functional-teams"
created: "2024-01-13T11:12:30.000Z"
tags:
  - cross-functional-teams
  - software-development
  - Agile
---

From its establishment to the present day, the IT sector has undergone a series
of transformations that revolutionized the way we collaborate and produce
software. Initially, teamwork was somewhat informal, with members piecing
together solutions in an improvised manner. However, as software grew in
complexity and the demand for intricate solutions escalated, the industry
required a greater degree of organization.

## The early days

In the "Automatic Programming - Definitions" article by [Grace M.
Hopper](https://en.wikipedia.org/wiki/Grace_Hopper), published in the [Symposium
on Automatic Programming for Digital Computers, 13-14 May
1954](https://www.google.com/books/edition/Symposium_on_Automatic_Programming_for_D/6AkgAAAAIAAJ),
the author is introducing the birth of specialized roles within a development
team as the following:

"_In the early days, some nine or ten years ago, a programmer was, of necessity,
many things. Numerical analyst, encoder-decoder, electrical or electronic
technician, detective and bug-hunter, and finally, evaluator. **The increase in
the number and speed of computers gave rise to specialization and with this
specialization, the definition of various types of languages for communication
among the specialists. As the analyst, programmer, coder, operator, and
maintenance man were separated, flow diagrams, flow charts and other aids to
communication were designed.** However, up until some three years ago, the only
means of communication with the computer remained the instruction code of the
operations built into the hardware._

_The distinction between a programmer and a coder has never been clearly made.
Coder was probably first used as an intermediate point on the salary scale
between trainee and programmer. A 'programmer' prepares a plan for the solution
of a problem. This plan may or may not include numerical and systems analysis,
but it surely includes plans for the handling of the input and output data from
source document to useful result. It is a plan for the flow of data and
operations by the computer and its auxiliary equipment as a part of a system. A
programmer's working tools are flow diagrams, schematic representations of the
problem, usually involving fairly gross symbols, and plain English. One of his
final results, to be passed on to a coder, will be a flow chart, a detailed
graphical representation of the sequence of operations the computer itself is
expected to perform._

_It is then the task of the coder to reduce this flow chart to coding, to a list
in computer code, the code representing the operations built into the hardware
of the computer, of the successive operations required to solve the problem._"

As we can see, the emergence of new roles and specialties was supplemented by
the need to create new communication tools, most of which are still in use
today. Additionally, a programmer and a coder were two separate roles due to
the lack of high-level programming languages and their corresponding
"translation" program (a compiler or an interpreter). Therefore, it was the job
of a coder to know the specific machine instructions and translate the schematic
representation of a problem into machine code.

Moreover, some of the duties carried out by early programmers have
been offloaded to the machine in the form of "..._diagnostic routines designed to
track down mistakes and malfunctions; test routines designed to demonstrate that
a computer was in working order and arbitrate the eternal debate as to whether
'it' stopped on a computer malfunction or a programming mistake_".
